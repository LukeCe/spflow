#' Create an inverted spatial filter that can be used for simulations
#'
#' @param weight_matrices A list of neighborhood matrices
#' @param autoreg_parameters A vector of parameters
#'
#' @family spflow simulation functions
#' @return A matrix representing the inverted spatial filter
#' @keywords internal
invert_spatial_filter <- function(
  weight_matrices,
  autoreg_parameters
) {

  combined_weight_matrices <-
    weight_matrices %>%
    safely_to_list() %>%
    plapply(., autoreg_parameters, .f = "*") %>%
    lreduce("+") %>%
    as.matrix()

  N <- nrow(combined_weight_matrices)

  return(solve(diag(N) - combined_weight_matrices))
}

#' Simulate spatial interactions
#'
#' @param exogenous_variables A matrix of exogenous variables
#' @param model_coefficients A numeric vector of coefficients
#' @param inverted_filter A matrix that represents an inverted spatial filter matrix (see [invert_spatial_filter()])
#' @param noise_sd A numeric which indicates the desired standard deviation of the simulated noise
#' @param verbose A logical whether signal to noise ration should be printed
#'
#' @family spflow simulation functions
#' @return A vector of simulated flows
#' @keywords internal
spflow_sim <- function(
  exogenous_variables,
  model_coefficients,
  inverted_filter,
  noise_sd,
  verbose = FALSE
) {

  # generate the flows
  signal <- inverted_filter %*% (exogenous_variables %*% model_coefficients)
  error <- rnorm(nrow(exogenous_variables),
                 sd = noise_sd)
  noise <- inverted_filter %*% error

  if (verbose) {
    cat("sd(noise)/sd(signal):\n")
    cat(sd(noise)/sd(signal), "\n")
  }

  return(as.vector(signal + noise))
}

#' Shape results of benchmarks for an [sp_flow_model()]
#'
#' @description
#' This function allows reshape results that are generated by [results_flat()]
#'
#' @family spflow simulation functions
#' @importFrom data.table := melt
#' @keywords internal
shape_spflow_benchmark <- function(dt, est_suffixes = c("_est","_sd"),
                                   ground_truth) {

  # identify keys and parameters
  suffix_pat <- "*" %p% est_suffixes %p% "$"
  all_suffix_pat <- paste0(suffix_pat, collapse = "|")
  is_param <- names(dt) %>% grepl(all_suffix_pat,.)
  key_vars <- names(dt)[!is_param]

  # reshape the data
  res_long <- melt(dt,id.vars = key_vars,
                   variable.name = "parameter",
                   value.name = "est_value")
  plapply(suffix_pat, est_suffixes, .f = function(pat,suf){
    res_long[grepl(pat,parameter), measure := gsub("_","",suf)]
  })
  res_long[, parameter := gsub(all_suffix_pat,"",parameter)]
  plapply(suffix_pat, est_suffixes, .f = function(pat,suf){
    res_long[grepl(pat,parameter), measure := gsub("_","",suf)]
  })

  # add the ground truth if available
  plapply(names(ground_truth),ground_truth, .f = function(.m,true_val){
    res_long[measure == .m, true_value :=  ground_truth[[.m]][parameter]
    ]
  })


  return(res_long)
}

#' @title Derive the flow neighborhood matrices
#'
#' @description
#' Use the neighborhood matrices of origins and destinations to derive the
#' three neighborhood matrices of the origin-destination flows.
#' This function is used for simulations or for comparisons with the vectorized
#' formulations of the model.
#'
#' @param OW Origin neighborhood matrix
#' @param DW Destination neighborhood matrix
#' @param n_o A numeric indicating the number of origins
#' @param n_d A numeric indicating the number of destinations
#' @param model A character indicating the model identifier
#'
#' @family spflow simulation functions
#' @importFrom Matrix Diagonal
#' @keywords internal
expand_flow_neighborhood <- function(
  OW,
  DW,
  n_o = OW %|!|% nrow(OW),
  n_d = DW %|!|% nrow(DW),
  model = "model_9") {

  # initialize weight matrices to NULL
  # then replace those that are required for the chosen model
  Wd <- NULL
  Wo <- NULL
  Ww <- NULL

  model_number <- substr(model,7,7) %>% as.integer()

  d_models <- c(2,5:9)
  o_models <- c(3,5:9)
  w_models <- c(4,6,8,9)

  if (model_number %in% d_models) {
    assert(!is.null(n_o) && !is.null(DW),
           "Construction the destination weight matrix requires arguments" %p%
             " for n_o and DW!")
    Wd <- Diagonal(n_o) %x% DW
  }

  if (model_number %in% o_models) {
    assert(!is.null(n_o) && !is.null(DW),
           "Construction the origin weight matrix requires arguments" %p%
             " for n_d and OW!")
    Wo <- OW %x% Diagonal(n_d)

  }

  if (model_number %in% w_models) {
    assert(!is.null(n_o) && !is.null(DW),
           "Construction the origin weight matrix requires arguments" %p%
             " for DW and OW!")
    Ww <- OW %x% DW
  }

  return(list("Wd" = Wd, "Wo" = Wo, "Ww" = Ww) %>% compact())
}


#' @title Derive the spatial filter of an interaction model
#'
#' @description
#' Use the neighborhood matrices of origins and destinations to derive the
#' three neighborhood matrices of the origin-destination flows.
#'
#'
#' @param weight_matrices List of flow neighborhood matrices
#' @param autoreg_parameters A numeric containing values for the
#'     auto-regressive parameters
#' @param invert A logical indicating whether the results should be inverted
#'
#' @family spflow simulation functions
#' @importFrom Matrix Diagonal Matrix
#' @keywords internal
spatial_filter <- function(
  weight_matrices,
  autoreg_parameters,
  invert = FALSE
) {

  combined_weight_matrices <-
    weight_matrices %>%
    safely_to_list() %>%
    mapply(FUN = "*", ., autoreg_parameters, SIMPLIFY = FALSE) %>%
    Reduce(f = "+", x = .) %>%
    Matrix()

  N <- nrow(combined_weight_matrices)
  A <- Diagonal(N) - combined_weight_matrices
  f_A <- if (invert) solve else x_

  return(A %>% f_A)
}


#' @title Derive the order of the spatial model
#'
#' @description
#' The order of a spatial model corresponds to the number of neighborhood
#' matrices that is used to describe the spatial dependence.
#'
#' @inheritParams spflow_control
#' @return An integer corresponding to the number of weight matrices
#' @keywords internal
spatial_model_order <- function(model = "model_9") {

  model_number <- substr(model,7,7)

  order0_models <- c(1)   %>% lookup(rep(0, length(.)), .)
  order1_models <- c(2:6) %>% lookup(rep(1, length(.)), .)
  order2_models <- c(7)   %>% lookup(rep(2, length(.)), .)
  order3_models <- c(8,9) %>% lookup(rep(3, length(.)), .)

  model_order <- c(order0_models,order1_models,order2_models,order3_models
  )[model_number]

  return(as.integer(model_order))
}
