#' @title
#' Estimate spatial interaction models that incorporate spatial dependence
#'
#' @description
#' We implement three different estimators of spatial interaction models that
#' allow the user to estimate origin-destination flow models with spatial
#' auto-correlation.
#'
#' By default the estimation will include spatial dependence in the dependent
#' variable and the explanatory variables which leads to a so called Spatial
#' Durbin model (SDM) \insertCite{Anselin1988}{spflow}.
#' Moreover, the model includes an additional set of parameters for intra
#' regional flows that start and end in the same geographic site (as proposed
#' by \insertCite{LeSage2009;textual}{spflow}).
#' Both default options can be deactivated via the `flow_control` argument,
#' which gives fine grained control over the estimation.
#'
#'
#' @param flow_formula
#'   A formula specifying the spatial interaction model (for details see
#'   section Formula interface)
#' @param sp_multi_network
#'   A [sp_multi_network()] object that contains information on the origins,
#'   and the destinations and their neighborhood structure
#' @param network_pair_id
#'   A character indicating the id of a [sp_network_pair()], defaults to the
#'   first pair inside the [sp_multi_network()]
#' @param flow_control
#'   A list generated by [spflow_control()] that provides fine grained control
#'   over the estimation procedure
#' @return A [spflow_model()] object
#'
#'
#' @section Details:
#' Our estimation procedures make use of the matrix formulation introduced by
#' \insertCite{LeSage2008;textual}{spflow} and further developed by
#' \insertCite{Dargel2021;textual}{spflow} to reduce the computational effort and memory
#' requirements considerably.
#' See (#Dargel2020Sim) for an exhaustive simulation study.
#' The estimation procedure can be adjusted through the `estimation_method`
#' argument in [spflow_control()].
#'
#' ## Maximum likelihood estimation (MLE):
#' Maximum likelihood estimation is the default estimation procedure.
#' The matrix form estimation in the framework of this model was first
#' developed by \insertCite{LeSage2008;textual}{spflow} and then improved by
#' \insertCite{Dargel2021;textual}{spflow}.
#'
#' ## Spatial two-stage least squares (S2SLS):
#' The S2SLS estimator is an adaptation of the one proposed by
#' \insertCite{Kelejian1998;textual}{spflow}, to the case of origin-destination
#' flows, with up to three neighborhood matrices
#' \insertCite{Dargel2021;textual}{spflow}.
#' A similar estimation is done by \insertCite{Tamesue2016;textual}{spflow}.
#' The user can activate the S2SLS estimation via the `flow_control` argument
#' using the input `spflow_control(estimation_method = "s2sls")`.
#'
#' ## Bayesian Markov Chain Monte Carlo (MCMC):
#' The MCMC estimator is based on the ideas of
#' \insertCite{LeSage2009;textual}{spflow} and incorporates the improvements
#' proposed in (#Dargel2020Improve).
#' The estimation is based on a tuned Metropolis-Hastings sampler for the
#' auto-regressive parameters, and for the remaining parameters it uses Gibbs
#' sampling.
#' The routine uses 5500 iterations of the sampling procedure and considers the
#' first 2500 as burn-in period.
#' The user can activate the S2SLS estimation via the `flow_control` argument
#' using the input `spflow_control(estimation_method = "mcmc")`.
#'
#' ## Formula interface:
#' The function offers a formula interface adapted to spatial interaction
#' models, which has the following structure:
#' `Y ~ O_(X1) + D_(X2) + I_(X3) + G_(X4)`
#' This structure reflects the different data sources involved in such a model.
#' On the left hand side is the independent variable `Y` which corresponds to
#' the vector of flows.
#' On the right hand side we have all the explanatory variables.
#' The functions `O_(...)` and `D_(...)` indicate which variables are used as
#' characteristics of the origins and destinations respectively.
#' Similarly, `I_(...)` indicates variables that should be used for the
#' intra-regional parameters.
#' Finally, `G_(...)` declares which variables describe origin-destination
#' pairs, which most frequently will include a measure of distance.
#'
#' All the declared variables must be available in the provided
#' [sp_multi_network()] object, which gathers information on the origins and
#' destinations (inside [sp_network_nodes()] objects), as well as the
#' information on the origin-destination pairs (inside a [sp_network_pair()]
#' object).
#'
#' Using the shortcut notation `Y ~ .` is possible and will be interpreted as
#' usual, in the sense that we use all variables that are available for each
#' data source.
#' Also formulas such as `Y ~ . + G_(log(X4) + 1)` are possible.
#' When the dot shortcut is combined with explicit declaration it will only be
#' used for the non declared data sources.
#' The following examples illustrate this behaviour.
#' shortcut is combined with explicit declaration it will only be used for the
#' non declared data sources.
#'
#' ## Formula interface (examples):
#'
#' Consider the case where we have the flow vector `Y` and the distance vector
#' `DIST` available as information on origin-destination pairs.
#' In addition we have  the explanatory variables `X1, X2` and `X3` which
#' describe the regions that are at the same time origins and destinations of
#' the flows.
#'
#' For this example the four formulas below are equivalent and make use of all
#' explanatory variables `X1, X2` and `X3` for origins, destinations and
#' intra-regional observations.
#'
#' - `Y ~ .`
#' - `Y ~ . + G_(DIST)`
#' - `Y ~ X1 + X2 + X3 + G_(DIST)`
#' - `Y ~ D_(X1 + X2 + X3) + O_(X1 + X2 + X3) + I_(X1 + X2 + X3)  + G_(DIST)`
#'
#' Now if we only want to use X1 for the intra-regional model we can do the
#' following (again all four options below are equivalent).
#'
#' - `Y ~ . + I_(X1)`
#' - `Y ~ . + I_(X1) + G_(DIST)`
#' - `Y ~  X1 + X2 + X3 + I_(X1) + G_(DIST)`
#' - `Y ~ D_(X1 + X2 + X3) + O_(X1 + X2 + X3) + I_(X1)  + G_(DIST)`
#'
#' This behaviour is easily combined with transformation of variables as the
#' two equivalent options below illustrate.
#'
#' - `log(Y + 1) ~ sqrt(X1) +  X2 + G_(log(DIST + 1))`
#' @examples
#'
#' # Estimate flows between the states of Germany
#' spflow(flow_formula = y9 ~ . + G_(log(distance + 1)),
#'        sp_multi_network = multi_net_usa_ge,
#'        network_pair_id = "ge_ge")
#'
#' \dontrun{
#' # Same as above with explicit declaration of variables...
#' # ... X is the only variable available
#' # ... it is used for origins, destination and intra-state flows
#' spflow(flow_formula = y9 ~ X + G_(log(distance + 1)),
#'        sp_multi_network = multi_net_usa_ge,
#'        network_pair_id = "ge_ge")
#'
#' # Same as above
#' spflow(flow_formula = y9 ~ O_(.) + D_(.) + I_(.) + G_(log(distance + 1)),
#'        sp_multi_network = multi_net_usa_ge,
#'        network_pair_id = "ge_ge")
#'
#' # Same as above
#' spflow(flow_formula = y9 ~ O_(X) + D_(X) + I_(X) + G_(log(distance + 1)),
#'        sp_multi_network = multi_net_usa_ge,
#'        network_pair_id = "ge_ge")
#' }
#'
#'
#' @references \insertAllCited{}
#' @seealso [spflow_control()]
#' @export
spflow <- function(
  flow_formula,
  sp_multi_network,
  network_pair_id = id(sp_multi_network,"network_pairs")[[1]]["pair"],
  flow_control = spflow_control()
) {

  ## ... check for abusive inputs
  assert(is(flow_formula,"formula"),
         "A valid formula is required!")

  assert(is(sp_multi_network,"sp_multi_network"),
         "The data must be a network data object!")

  ## ... check correct types of ids
  assert(is_single_character(network_pair_id),
         "The network_pair_id must be a character of length 1!")

  network_ids <- id(sp_multi_network)[["network_pairs"]][[network_pair_id]]
  assert(!is.null(network_ids),
         "The the network pair id [%s] is not available!" %>%
           sprintf(., network_pair_id))


  ## ... test the arguments provided to control by calling it again
  assert(is.null(flow_control$weight_variable),warn = TRUE,
         "Weighting of observations is not yet possible and will be ignored.")

  flow_control <- do.call(spflow_control, flow_control)
  # TODO validate and enrich flow control
  # TODO check completeness information and add to estimation control
  ## ... identify the flow type
  flow_control$flow_type <- ifelse(
    network_ids["orig"] ==
      network_ids["dest"],
    yes = "within", no = "between"
  )
  flow_control$flow_completeness <- (
    npairs(pull_pairs(sp_multi_network, network_pair_id)) /
      prod(nnodes(pull_pairs(sp_multi_network, network_pair_id)))
  )
  flow_control$sp_model_type <- sp_model_type(flow_control)


  # TODO generalize for the case of sparse flows and multiple networks
  assert(flow_control$flow_completeness == 1,
         "Estimation are for only possible if the number of pairs is excatly
         the number of origins multiplied by the number of destinations!")

  assert(flow_control$flow_type == "within",
         "Estimation of flows between two diffrent networks are " %p%
         "not yet available!")

  ## ... create the design matrix/matrices
  model_matrices <- spflow_model_matrix(
    sp_multi_network,
    network_pair_id,
    flow_formula,
    flow_control)

  # ... fit the model and add complementary information to the results
  estimation_results <- spflow_model_estimation(model_matrices,flow_control)

  return(estimation_results)
}



#' @keywords internal
parameter_names <- function(
  model_matrices,
  model) {

  names_rho <- identify_auto_regressive_parameters(model)
  names_const <- c("Constant", "Constant_intra")
  use_const <- c(model_matrices$constants$global == 1,
                 !is.null(model_matrices$constants$intra$In))
  names_const <- names_const[use_const]

  x_prefs <- list("D_" = "Dest_","O_" = "Orig_","I_" = "Intra_")
  names_X <- model_matrices[names(x_prefs)] %>% compact() %>%
    lapply("colnames") %>% plapply(x_prefs[names(.)],., .f = "%p%") %>%
    flatten(use.names = FALSE)

  names_G <- names(model_matrices$G)
  export_names <- c(names_rho,names_const,names_X,names_G)

  return(export_names)

}

#' @keywords internal
drop_instruments <- function(model_matrices) {

  # ... from constants
  filter_inst <- function(x) lfilter(x, function(x) !get_instrument_status(x))
  constants <- list(
    "global" = model_matrices$constants$global,
    "intra" = model_matrices$constants$intra %>% filter_inst())

  # ... from site attributes
  filter_inst_col <- function(x) cols_drop(x,get_instrument_status(x))
  vector_treatment <- c("D","O","I") %p% "_"
  matrices_X <- model_matrices[vector_treatment] %>%
    compact() %>% lapply("filter_inst_col")

  # ... from pair attributes
  matrices_G <- model_matrices["G_"] %>% lapply("filter_inst")

  # ... combine cleaned versions
  matrices_and_spatial_weights <- c(
    model_matrices["Y_"],
    list("constants" = constants),
    matrices_X,
    matrices_G,
    model_matrices[c("DW","OW")] %>% compact()
  )

  return(matrices_and_spatial_weights)
}
