#' @title
#' Generate the design matrices for the spatial interaction model
#'
#' @description
#' Create the model matrices required for matrix-form estimation of
#' the spatial econometric interaction model.
#'
#' @details
#' The key to an efficient estimation is to preserve the relational
#' representation of the data for origins, destinations and
#' origins-destinations pairs.
#' This requires to be aware of the;
#'  - three sources of data (pair, orig, dest)
#'  - three parts of the formula (norm, sdm, inst)
#'  - five roles of the variables (Y_, G_, D_, O_, I_)
#'
#' The additional separation of data sources and roles makes sense if the list
#' of origins coincides with the list of destinations.
#' In this case, we can use data from the same source as origin, destination,
#' or intra-regional characteristics.
#'
#' The model formulas contain information about mathematical transformations
#' of the variables and allow to deduce number of spatial lags required for
#' each of them.
#' To apply the transformations we use R's build-in tools for handling formulas.
#' Spatial lags are calculated after the transformations have been applied.
#' Below is an explanation of the formula parts:
#'  - norm variables are not lagged
#'  - sdm variables are lagged once and used as explanatory variables
#'  - inst variables are lagged twice and used as instruments.
#'   If a variable is at the same time inst and sdm we have to increase the
#'   lags-order to avoid duplicating columns
#'   (see \insertCite{Dargel2021}{spflow}).
#'
#' @references \insertAllCited{}
#' @name derive_spflow_matrices
#' @keywords internal
#' @return A list of design matrices for the spatial interaction model
derive_spflow_matrices <- function(
  spflow_data,
  spflow_neighborhood,
  spflow_formula,
  spflow_control,
  na_rm = FALSE) {


  fourmulas_by_part <- interpret_spflow_formula(spflow_formula, spflow_control)
  fourmulas_by_source <- translist(fourmulas_by_part)

  spflow_matrices <- named_list(c("CONST","D_","O_","I_","G_","Y_"))
  spflow_indicators <- subset_keycols(spflow_data[["pair"]], drop_keys = FALSE)
  stop("indiactors are wrong!")

  spflow_matrices[["CONST"]] <- derive_spflow_constants(
    use_global_const = fourmulas_by_part[["constants"]][["global"]],
    use_intra_const = isTRUE(fourmulas_by_part[["constants"]][["intra"]]),
    use_instruments = spflow_control[["estimation_method"]] == "s2sls",
    spflow_indicators = spflow_indicators,
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]])


  ### transform and lag node data
  assert_NA <- function(matrix_key) assert(na_rm, "NA's generated by formula part %s(...)!", matrix_key)
  complete_nodeobs <- function(matrix_key) {

    obs_X <- spflow_matrices[[matrix_key]] %|!|% complete.cases
    if (all(obs_X))
      return(NULL)

    assert_NA(matrix_key)
    return(obs_X)
  }

  spflow_matrices[["D_"]] <- transform_node_data(
    threepart_formula = fourmulas_by_source[["D_"]],
    node_df = subset_keycols(spflow_data[["dest"]]),
    W = spflow_neighborhood[["DW"]],
    ignore_border_effects = spflow_control[["ignore_border_effects"]],
    prefix = "DEST_")
  obs_D <- complete_nodeobs("D_")


  spflow_matrices[["O_"]] <- transform_node_data(
    threepart_formula = fourmulas_by_source[["O_"]],
    node_df = subset_keycols(spflow_data[["orig"]]),
    W = spflow_neighborhood[["OW"]],
    ignore_border_effects = spflow_control[["ignore_border_effects"]],
    prefix = "ORIG_")
  obs_O <- complete_nodeobs("O_")


  spflow_matrices[["I_"]] <- transform_node_data(
    threepart_formula = fourmulas_by_source[["I_"]],
    node_df = subset_keycols(spflow_data[["orig"]]),
    W = spflow_neighborhood[["OW"]],
    ignore_border_effects = spflow_control[["ignore_border_effects"]],
    prefix = "INTRA_")
  obs_I <- complete_nodeobs("I_")


  ### transform and lag od-pair data
  incomplete_pairobs <- function(matrix_key) {
    na_cases <- Reduce("&", lapply(spflow_matrices[[matrix_key]], is.na))
    if (!any(na_cases))
      return(NULL)

    assert_NA(matrix_key)
    return(na_cases)
  }

  spflow_matrices[["G_"]] <- transform_pair_data(
    threepart_formula = fourmulas_by_source[["G_"]],
    pair_df = subset_keycols(spflow_data[["pair"]]),
    spflow_indicators = spflow_indicators,
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]],
    ignore_border_effects = spflow_control[["ignore_border_effects"]],
    reduce_pair_instruments = isTRUE(spflow_control[["twosls_reduce_pair_instruments"]]))
  na_G <- incomplete_pairobs("G_")

  spflow_matrices[["Y_"]] <- transform_flow_data(
    threepart_formula = fourmulas_by_source[["Y_"]],
    flow_df = subset_keycols(spflow_data[["pair"]]),
    spflow_indicators = spflow_indicators,
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]],
    model = spflow_control[["model"]],
    ignore_border_effects = spflow_control[["ignore_border_effects"]])
  na_Y <- incomplete_pairobs("Y_")

  # identify which information sets are available for each od pair
  # ... predictions require signal
  update_conditions <- function(pre,add) if (is.null(pre)) add else pre & add
  HAS_SIG <- NULL
  do_indexes <- cbind(as.integer(spflow_indicators[[1]]), spflow_indicators[[2]])
  if (!all(obs_D))
    HAS_SIG <- update_conditions(HAS_SIG, obs_D[do_indexes[1]])

  if (!all(obs_O))
    HAS_SIG <- update_conditions(HAS_SIG, obs_O[do_indexes[2]])

  if (!all(obs_I))
    HAS_SIG <- update_conditions(HAS_SIG, (obs_I[do_indexes[2]] | spflow_indicators[[2]] != spflow_indicators[[1]]))

  if (!is.null(na_G))
    HAS_SIG <- update_conditions(HAS_SIG, !(na_G[do_indexes]))


  # ... model fitting requires signal, y, y_lags, and non-zero weights
  HAS_Y <- HAS_SIG
  if (!is.null(na_Y))
    HAS_Y <- update_conditions(HAS_Y, !(na_Y[do_indexes]))

  WEIGHT <- spflow_control[["weight_var"]]
  if (!is.null(WEIGHT) ) {
    WEIGHT <- spflow_data[[WEIGHT]]
    WEIGHT[WEIGHT <= 0] <- NA
    HAS_Y <- update_conditions(HAS_Y, is.finite(WEIGHT))
    WEIGHT[!HAS_Y] <- 0
  }

  extra_indicators <- cbind(HAS_SIG, HAS_Y, WEIGHT, ACTUAL = spflow_matrices[["Y_"]][[1]][do_indexes])
  spflow_indicators <- cbind(spflow_indicators, extra_indicators)
  return(c(spflow_matrices, list(spflow_indicators = spflow_indicators)))
}


# ---- matrix generators ------------------------------------------------------
#' @importFrom Matrix Diagonal
#' @keywords internal
derive_spflow_constants <- function(
  use_global_const,
  use_intra_const,
  use_instruments,
  spflow_indicators = NULL,
  OW = NULL,
  DW = NULL) {


  c_terms <- list("(Intercept)" =  `attr_inst_status<-`(1, !use_global_const))
  if (!use_intra_const)
    return(c_terms)

  n <- nlevels(spflow_indicators[[1]])
  c_terms <- c(c_terms, "(Intra)" = `attr_inst_status<-`(Diagonal(n), FALSE))
  if (!use_instruments)
    return(c_terms)

  # for computation of instruments the indicator is based on observed Y
  Y_indicator <- spflow_indicators2mat(spflow_indicators, do_filter = "HAS_Y")
  intra_lags <- double_lag_matrix(
    M = Diagonal(n),
    OW = OW,
    DW = DW,
    name = "(Intra)",
    key = "I",
    M_indicator = Y_indicator,
    symmetric_lags = is.null(Y_indicator),
    lag_order = 2,
    return_all_lags = TRUE,
    lags_are_instruments = TRUE)
  return(c(c_terms, intra_lags[-1]))
}


#' @keywords internal
transform_node_data <- function(
  threepart_formula,
  node_df,
  W,
  ignore_border_effects,
  prefix = "") {


  if (is.null(threepart_formula) | is.null(node_df))
    return(NULL)

  # transformation according to the formula
  combined_formula <- combine_rhs_formulas(threepart_formula)
  node_df <- subset_keycols(node_df, drop_keys = TRUE)
  node_mat <- flow_conform_model_matrix(combined_formula, node_df)
  lostobs <- get_lostobs(node_df, node_mat)
  node_mat <- impute_lost_cases(node_mat, lostobs, ifelse(ignore_border_effects, 0, NA))

  # spatial lags for sdm and instrument parts
  var_use <- derive_variables_use(threepart_formula, node_df)
  lag_num2var <- lookup(as.integer(var_use[["num_lags"]]), row.names(var_use))
  node_mat <- add_lagged_cols(node_mat, W, lag_num2var)
  revert_zero_imputation <- ignore_border_effects & !is.null(lostobs)
  if (revert_zero_imputation)
    node_mat[lostobs,] <- NA

  inst_status2var <- unlist(var_use[["inst_attr"]])
  inst_order2var <- c(which(!inst_status2var),which(inst_status2var))
  node_mat <- node_mat[,inst_order2var,drop = FALSE]
  colnames(node_mat) <- paste0(prefix, colnames(node_mat))
  attr_inst_status(node_mat) <- sort(inst_status2var)

  return(node_mat)
}


#' @keywords internal
transform_pair_data <- function(
  threepart_formula,
  pair_df,
  spflow_indicators,
  OW,
  DW,
  ignore_border_effects,
  reduce_pair_instruments) {

  if (is.null(threepart_formula) | is.null(pair_df))
    return(NULL)

  # transformation according to the formula and concert to matrix-list format
  combined_formula <- combine_rhs_formulas(threepart_formula)
  pair_mat <- flow_conform_model_matrix(combined_formula, pair_df)
  lostobs <- get_lostobs(pair_df, pair_mat)
  pair_mat <- impute_lost_cases(pair_mat, lostobs, ifelse(ignore_border_effects, 0, NA))
  pair_mat <- spflow_indicators2matlist(cbind(spflow_indicators[,1:2], pair_mat))


  # spatial lags for instrument parts
  var_use <- derive_variables_use(threepart_formula, pair_df)
  lag_num2var <- lookup(as.integer(var_use[["num_lags"]]),row.names(var_use))
  pair_mat <-
    Reduce("c", lapply(lookup(names(pair_mat)),  function(.var) {
      double_lag_matrix(
        M = pair_mat[[.var]],
        DW = OW,
        OW = DW,
        name = .var,
        key = "G",
        M_indicator = spflow_indicators2mat(spflow_indicators),
        lag_order = lag_num2var[.var],
        return_all_lags = !reduce_pair_instruments,
        lags_are_instruments = TRUE)}))

  revert_zero_imputation <- ignore_border_effects & !is.null(lostobs)
  if (revert_zero_imputation) {
      na_pos <- Reduce("cbind", lapply(spflow_indicators[lostobs,1:2], "as.integer"))
      for (m in seq_along(flow_mat)) pair_mat[[m]][na_pos] <- NA
  }

  return(pair_mat)
}

#' @keywords internal
transform_flow_data <- function(
  threepart_formula,
  flow_df,
  spflow_indicators,
  OW,
  DW,
  model,
  ignore_border_effects) {

  if (is.null(threepart_formula) | is.null(flow_df))
    return(NULL)


  combined_formula <- combine_rhs_formulas(threepart_formula)
  flow_mat <- flow_conform_model_matrix(combined_formula, flow_df)
  lostobs <- get_lostobs(flow_df, flow_mat)
  flow_mat <- impute_lost_cases(flow_mat, lostobs, ifelse(ignore_border_effects, 0, NA))
  flow_mat <- spflow_indicators2matlist(cbind(spflow_indicators[,1:2], flow_mat))


  flow_mat <- Reduce("c", Map(function(.var, .mat) {
    lag_flow_matrix(
      Y = .mat,
      model = model,
      DW = OW,
      OW = DW,
      name = .var,
      M_indicator = spflow_indicators2mat(spflow_indicators))},
    .var = names(flow_mat),
    .mat = flow_mat))

  revert_zero_imputation <- ignore_border_effects & !is.null(lostobs)
  if (revert_zero_imputation) {
    na_pos <- Reduce("cbind", lapply(spflow_indicators[lostobs,1:2], "as.integer"))
    for (m in seq_along(flow_mat)) flow_mat[[m]][na_pos] <- NA
  }


  return(flow_mat)
}

# ---- helpers ----------------------------------------------------------------
#' @keywords internal
pull_spflow_data <- function(
  sp_multi_net,
  pair_id) {

  source_ids <- as.list(id(sp_multi_net@network_pairs[[pair_id]]))
  flow_data <- lapply(source_ids, function(.id){
    source_data <- dat(sp_multi_net, .id)
    row.names(source_data) <- NULL
    source_data
  })
  return(flow_data)
}

#' @keywords internal
get_keycols <- function(df) {
  c(attr_key_do(df),
    attr_key_nodes(df),
    attr_coord_col(df))
}

#' @keywords internal
subset_keycols <- function(df, drop_keys = TRUE) {
  keep_cols <- get_keycols(df)
  if (drop_keys)
    keep_cols <- setdiff(names(df), keep_cols)
  return(df[, keep_cols, drop = FALSE])
}

#' @keywords internal
flow_conform_model_matrix <- function(formula,data) {
  terms_obj <- terms(formula, data = data)
  attr(terms_obj,"intercept") <- formula_expands_factors(formula,data) * 1
  mat <- model.matrix(terms_obj,data)
  mat[,colnames(mat) != "(Intercept)", drop = FALSE]
}

#' @keywords internal
get_lostobs <- function(pre, trans) {
  if (is.null(pre) || is.null(trans) || nrow(trans) == nrow(pre))
    return(NULL)

  lost <- rep(TRUE, nrow(pre))
  lost[as.integer(row.names(trans))] <- FALSE
  return(lost)
}

#' @keywords internal
derive_variables_use <- function(
  formula_part,
  data_source) {

  var_use <- lapply(formula_part, "predict_tranfomed_vars", data_source)
  var_use_types <- named_list(c("norm","sdm","inst"))
  var_use_types[names(var_use)] <- var_use

  all_vars <- unique(unlist(var_use, use.names = FALSE))
  get_v_use <- function(.v) data.frame(lapply(var_use_types, function(.u) any(.u == .v)))
  var_use_df <- do.call("rbind", lapply(lookup(all_vars), get_v_use))
  var_use_df[["num_lags"]] <- var_use_df[["sdm"]] + 2 * var_use_df[["inst"]]

  inst_attr <- Map(
    function(norm, sdm, num_lags){

      inst_statu <- rep(TRUE, num_lags + 1)
      inst_statu[1] <- !norm
      if(num_lags >= 1)
        inst_statu[2] <- !sdm
      inst_statu
    },
    var_use_df$norm, var_use_df$sdm, var_use_df$num_lags)

  var_use_df[["inst_attr"]] <- I(inst_attr)
  var_use_df
}

