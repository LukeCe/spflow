#' @title Internal functions to generate model matrices
#' @details
#'   Sources describe the data.frames holding the original information on
#'   the nodes and the node pairs. There are three possible source data.frame
#'   which are referred to as "pair", "orig", or "dest".
#'   All formulas (normal, sdm, and instrument) are combined to generate an
#'   overall model matrix which is only expanded once for each source.
#' @return A list of matrices
#' @keywords internal
transform_spflow_data <- function(
    formula_parts,
    spflow_data,
    na_rm,
    weights_var,
    is_within) {

  formulas2sources  <- c(
    "D_" = ifelse(is_within, "orig", "dest"),
    "O_" = "orig",
    "I_" = "orig",
    "G_" = "pair",
    "Y_" = "pair")

  formulas4trans <- translist(formula_parts)[names(formulas2sources)]
  formulas4trans <- lapply(
    formulas4trans[intersect(names(formulas4trans), names(formulas2sources))],
    "combine_rhs_formulas")

  for (i in seq_along(spflow_data))
    row.names(spflow_data) <- NULL

  # transform nodes variables
  transform_in_source <- function(.key, .na_rm = na_rm, filter = NULL) {

    this_formula <- formulas4trans[[.key]]
    if (is.null(this_formula))
      return(NULL)

    this_source <- formulas2sources[.key]
    this_source <- subset_keycols(spflow_data[[this_source]], drop_keys = TRUE)
    if (!is.null(filter))
      this_source <- this_source[filter,,drop = FALSE]
    this_mat <- flow_conform_model_matrix(this_formula, this_source)

    lost_cases <- nrow(this_mat) < nrow(this_source)
    assert(.na_rm || !lost_cases, "NA's generated by formula part %s(...)!", .key)
    return(this_mat)
  }
  node_formulas <- c("D_","O_", "I_")
  node_matrices <- lapply(lookup(node_formulas), transform_in_source)

  # ...if there are lost observations in the node matrices
  lost_nodes <- lapply(lookup(node_formulas), function(.f) get_lostobs(
    pre = spflow_data[[formulas2sources[.f]]],
    trans = node_matrices[[.f]]))
  node_matrices <- Map(impute_lost_cases, node_matrices, lost_nodes, imp = NA)
  lost_nodes <- compact(lost_nodes) %||% NULL

  # ...we will not be able to compute the signal for the corresponding pair
  wt <- weights_var %|!|% as.numeric(spflow_data[["pair"]][[weights_var]])
  spflow_indicators <- get_do_keys(spflow_data[["pair"]])
  HAS_SIG <- NULL
  if (!is.null(lost_nodes)) {
    pair_indexes <- c("D_" = 1,"O_" = 2, "I_" = 2)[names(lost_nodes)]
    pair_indexes <- spflow_indicators[,as.numeric(pair_indexes), drop = FALSE]
    HAS_SIG <- Map(function(.l, .i) (!.l)[as.numeric(.i)], .l = lost_nodes, .i = pair_indexes)
    HAS_SIG <- Reduce("&", HAS_SIG)
  }

  # transform pair variables
  G_matrices <- transform_in_source("G_", na_rm,filter = HAS_SIG)
  G_losses <- get_lostobs(spflow_indicators, G_matrices)
  if (!is.null(G_losses)) {
    HAS_SIG  <- if (is.null(HAS_SIG)) !G_losses else !G_losses & HAS_SIG
  }

  # transform y variables
  # when there is no signal we cannot use y....
  HAS_Y <- NULL
  if (!is.null(wt)) {
    wt_valid <- (is.finite(wt) & wt > 0)
    assert(na_rm || all(wt_valid), "The weights contain NA/NaN/Inf/negative values!")
    HAS_Y <- if (is.null(HAS_Y)) wt_valid else wt_valid & HAS_Y
  }

  Y_matrices <- transform_in_source("Y_", na_rm, filter = HAS_Y)
  Y_losses <- get_lostobs(spflow_indicators, Y_matrices)
  if (!is.null(Y_losses)) {
    HAS_Y <- !Y_losses
    if (!is.null(wt))
      wt[Y_losses] <- 0
  }

  # in the indicators signal whether for model fitting and prediction
  # also store the dependent variables to compute residuals later
  Y_cases <- HAS_Y %||% TRUE
  G_cases <- HAS_SIG %||% TRUE
  extra_indicators <- data.frame(ACTUAL = NA)
  if (!is.null(wt))
    extra_indicators <- cbind(extra_indicators, WEIGHT = wt)
  if (!is.null(HAS_SIG))
    extra_indicators <- cbind(extra_indicators, HAS_SIG)
  if (!is.null(HAS_Y))
    extra_indicators <- cbind(extra_indicators, HAS_Y)
  spflow_indicators <- cbind(spflow_indicators, extra_indicators)
  spflow_indicators[,"ACTUAL"][Y_cases] <- Y_matrices

  # matrix format pair variables
  Y_matrices <- Y_matrices %|!|% spflow_indicators2matlist(cbind(spflow_indicators[Y_cases, 1:2, drop = FALSE], Y_matrices))
  G_matrices <- G_matrices %|!|% spflow_indicators2matlist(cbind(spflow_indicators[G_cases, 1:2, drop = FALSE], G_matrices))
  pair_matrices <- list(
    "G_" = G_matrices,
    "Y_" = Y_matrices,
    "spflow_indicators" = spflow_indicators)

  return(c(node_matrices, pair_matrices))
}

#' @keywords internal
combine_formulas_by_source <- function(sources, formulas) {

  is_between_flow <- ("dest" %in% sources)
  sources_to_formula_part <- list(
    "pair" = c("Y_","G_"),
    "dest" = c("D_") %T% is_between_flow,
    "orig" = (c("O_") %T% is_between_flow) %||% c("D_","O_","I_"))

  formula_by_source <-
    lapply(compact(sources_to_formula_part), function(.part) {
      fpt <- compact(formulas[.part])
      fpt %|!|% combine_rhs_formulas(fpt) })

  return(compact(formula_by_source))
}

#' @keywords internal
flow_conform_model_matrix <- function(formula,data) {
  terms_obj <- terms(formula, data = data)
  attr(terms_obj,"intercept") <- formula_expands_factors(formula,data) * 1
  mat <- model.matrix(terms_obj,data)
  mat[,colnames(mat) != "(Intercept)", drop = FALSE]
}


#' @keywords internal
transform_node_data <- function(
  threepart_formula,
  node_df,
  W,
  na_border2zero) {

  # transformation according to the formula
  combined_formula <- combine_rhs_formulas(threepart_formula)
  node_df <- subset_keycols(node_df, drop_keys = TRUE)
  node_mat <- flow_conform_model_matrix(combined_formula, node_df)
  lostobs <- get_lostobs(node_df, node_mat)
  node_mat <- impute_lost_cases(node_mat, lostobs, ifelse(na_border2zero, 0, NA))

  # spatial lags for sdm and instrument parts
  var_use <- derive_variables_use(threepart_formula, node_df)
  lag_num2var <- lookup(as.integer(var_use[["num_lags"]]),row.names(var_use))
  node_mat <- add_lagged_cols(node_mat, W, lag_num2var)
  revert_zero_imputation <- na_border2zero & !is.null(lostobs)
  if (revert_zero_imputation)
    node_mat[lostobs,] <- NA

  inst_status2var <- unlist(var_use[["inst_attr"]])
  inst_order2var <- cbind(which(inst_status2var),which(!inst_status2var))
  node_mat <- node_mat[inst_order2var,,drop = FALSE]
  attr_inst_status(node_mat) <- sort(inst_status2var)

  return(node_mat)
}


#' @keywords internal
transform_pair_data <- function(
  threepart_formula,
  pair_df,
  M_indicator,
  OW,
  DW,
  na_border2zero,
  reduce_pair_instruments) {


  # transformation according to the formula and concert to matrix-list format
  combined_formula <- combine_rhs_formulas(threepart_formula)
  pair_mat <- flow_conform_model_matrix(combined_formula, pair_df)
  lostobs <- get_lostobs(pair_df, pair_mat)
  pair_mat <- impute_lost_cases(pair_mat, lostobs, ifelse(na_border2zero, 0, NA))
  pair_mat <- spflow_indicators2matlist(cbind(spflow_indicators[,1:2], pair_mat))


  # spatial lags for instrument parts
  var_use <- derive_variables_use(threepart_formula, pair_df)
  lag_num2var <- lookup(as.integer(var_use[["num_lags"]]),row.names(var_use))
  pair_mat <-
    Reduce("c", lapply(lookup(names(pair_mat)),  function(.var) {
      double_lag_matrix(
        M = pair_mat[[.var]],
        DW = OW,
        OW = DW,
        name = .var,
        key = "G",
        M_indicator = M_indicator,
        lag_order = lag_num2var[.var],
        return_all_lags = !reduce_pair_instruments,
        lags_are_instruments = TRUE
      )}))

  # return matrices and indicate where data is missing due to NA's
  if (is.null(lostobs))
    return(pair_mat)

  set_na0 <- function(mat_list) lapply(mat_list, function(.m) {

    if (inherits(.m, "Matrix")) {
      .m@x[is.na(.m@x)] <- 0
      return(drop0(.m))
    }

    .m[is.na(.m)] <- 0
    return(.m)
  })
  if (na_border2zero | max(lag_num2var) == 0) {
    pair_mat <- lapply(pair_mat, set_na0)
    return(c(pair_mat, HAS_SIG = !lostobs))
  }

  if (!na_border2zero) {
    get_lostobs_lags <- function(mat_list) Reduce("&", lapply(mat_list[-1], is.na))
    lostobs_lags <- lapply(pair_mat, length) > 1
    lostobs_lags <- Reduce("&", lapply(pair_mat[lostobs_lags], get_lostobs_lags))
    lostobs_lags <- lostobs_lags[M_indicator] & lostobs

    pair_mat <- lapply(pair_mat, set_na0)
    return(c(pair_mat, HAS_SIG = !lostobs_lags))
  }
}


#' @keywords internal
transform_flow_data <- function(
  threepart_formula,
  flow_df,
  M_indicator,
  OW,
  DW,
  model,
  na_border2zero) {


  # transformation according to the formula and concert to matrix-list format
  combined_formula <- combine_rhs_formulas(threepart_formula)
  flow_mat <- flow_conform_model_matrix(combined_formula, flow_df)
  lostobs <- get_lostobs(flow_df, flow_mat)
  flow_mat <- impute_lost_cases(flow_mat, lostobs, ifelse(na_border2zero, 0, NA))
  flow_mat <- spflow_indicators2matlist(cbind(spflow_indicators[,1:2], flow_mat))


  # spatial lags
  flow_mat <-
    Reduce("c", lapply(lookup(names(flow_mat)),  function(.var) {
      lag_flow_matrix(
        M = flow_mat[[.var]],
        model = model,
        DW = OW,
        OW = DW,
        name = .var,
        M_indicator = M_indicator)}))

  # return matrices and indicate where data is missing due to NA's
  if (is.null(lostobs))
    return(flow_mat)

  set_na0 <- function(mat_list) lapply(mat_list, function(.m) {

    if (inherits(.m, "Matrix")) {
      .m@x[is.na(.m@x)] <- 0
      return(drop0(.m))
    }

    .m[is.na(.m)] <- 0
    return(.m)
  })
  if (na_border2zero | max(lag_num2var) == 0) {
    flow_mat <- lapply(flow_mat, set_na0)
    return(c(flow_mat, HAS_Y = !lostobs))
  }

  if (!na_border2zero) {
    get_lostobs_lags <- function(mat_list) Reduce("&", lapply(mat_list[-1], is.na))
    lostobs_lags <- lapply(flow_mat, length) > 1
    lostobs_lags <- Reduce("&", lapply(flow_mat[lostobs_lags], get_lostobs_lags))
    lostobs_lags <- lostobs_lags[M_indicator] & lostobs

    flow_mat <- lapply(flow_mat, set_na0)
    return(c(flow_mat, HAS_Y = !lostobs_lags))
  }
}


#' @keywords internal
get_lostobs <- function(pre, trans) {
  if (is.null(pre) || is.null(trans) || nrow(trans) == nrow(pre))
    return(NULL)

  lost <- rep(TRUE, nrow(pre))
  lost[as.integer(row.names(trans))] <- FALSE
  return(lost)
}


