#' Create an inverted spatial filter that can be used for simulations
#'
#' @param weight_matrices A list of neighborhood matrices
#' @param autoreg_parameters A vector of parameters
#'
#' @family spflow_simulations
#' @return A matrix representing the inverted spatial filter
invert_spatial_filter <- function(
  weight_matrices,
  autoreg_parameters
) {

  combined_weight_matrices <-
    weight_matrices %>%
    safely_to_list() %>%
    plapply(., autoreg_parameters, .f = "*") %>%
    lreduce("+") %>%
    as.matrix()

  N <- nrow(combined_weight_matrices)

  return(solve(diag(N) - combined_weight_matrices))
}

#' Simulate spatial interactions
#'
#' @param exogenous_variables A matrix of exogenous variables
#' @param model_coefficients A numeric vector of coefficients
#' @param inverted_filter A matrix that represents an inverted spatial filter matrix (see [invert_spatial_filter()])
#' @param noise_sd A numeric which indicates the desired standard deviation of the simulated noise
#' @param verbose A logical whether signal to noise ration should be printed
#'
#' @family spflow_simulations
#' @return A vector of simulated flows
#' @export
spflow_sim <- function(
  exogenous_variables,
  model_coefficients,
  inverted_filter,
  noise_sd,
  verbose = FALSE
) {

  # generate the flows
  signal <- inverted_filter %*% (exogenous_variables %*% model_coefficients)
  error <- rnorm(nrow(exogenous_variables),
                 sd = noise_sd)
  noise <- inverted_filter %*% error

  if (verbose) {
    cat("sd(noise)/sd(signal):\n")
    cat(sd(noise)/sd(signal), "\n")
  }

  return(as.vector(signal + noise))
}

#' Shape results of benchmarks for an [sp_flow_model()]
#'
#' @description
#' This function allows reshape results that are generated by [results_flat()]
#'
#' @family spflow_simulations
#' @importFrom data.table := melt
#' @export
shape_spflow_benchmark <- function(dt, est_suffixes = c("_est","_sd"),
                                   ground_truth) {

  # identify keys and parameters
  suffix_pat <- "*" %p% est_suffixes %p% "$"
  all_suffix_pat <- paste0(suffix_pat, collapse = "|")
  is_param <- names(dt) %>% grepl(all_suffix_pat,.)
  key_vars <- names(dt)[!is_param]

  # reshape the data
  res_long <- melt(dt,id.vars = key_vars,
                   variable.name = "parameter",
                   value.name = "est_value")
  plapply(suffix_pat, est_suffixes, .f = function(pat,suf){
    res_long[grepl(pat,parameter), measure := gsub("_","",suf)]
  })
  res_long[, parameter := gsub(all_suffix_pat,"",parameter)]
  plapply(suffix_pat, est_suffixes, .f = function(pat,suf){
    res_long[grepl(pat,parameter), measure := gsub("_","",suf)]
  })

  # add the ground truth if available
  plapply(names(ground_truth),ground_truth, .f = function(.m,true_val){
    res_long[measure == .m, true_value :=  ground_truth[[.m]][parameter]
    ]
  })


  return(res_long)
}
