#' @title
#' Generate the design matrices for the spatial interaction model
#'
#' @description
#' Create the model matrices required for matrix-form estimation of
#' the spatial econometric interaction model.
#'
#' @details
#' The key to an efficient estimation is to preserve the relational
#' representation of the data for origins, destinations and
#' origins-destinations pairs.
#' This requires to be aware of the;
#'  - three sources of data (pair, orig, dest)
#'  - three parts of the formula (norm, sdm, inst)
#'  - five roles of the variables (Y_, G_, D_, O_, I_)
#'
#' The additional separation of data sources and roles makes sense if the list
#' of origins coincides with the list of destinations.
#' In this case, we can use data from the same source as origin, destination,
#' or intra-regional characteristics.
#'
#' The model formulas contain information about mathematical transformations
#' of the variables and allow to deduce number of spatial lags required for
#' each of them.
#' To apply the transformations we use R's build-in tools for handling formulas.
#' Spatial lags are calculated after the transformations have been applied.
#' Below is an explanation of the formula parts:
#'  - norm variables are not lagged
#'  - sdm variables are lagged once and used as explanatory variables
#'  - inst variables are lagged twice and used as instruments.
#'   If a variable is at the same time inst and sdm we have to increase the
#'   lags-order to avoid duplicating columns
#'   (see \insertCite{Dargel2021}{spflow}).
#'
#' @references \insertAllCited{}
#' @name derive_spflow_matrices
#' @keywords internal
#' @return A list of design matrices for the spatial interaction model
derive_spflow_matrices <- function(
  spflow_data,
  spflow_neighborhood,
  spflow_formula,
  spflow_control,
  na_rm = FALSE) {


  fourmulas_by_part <- interpret_spflow_formula(spflow_formula, spflow_control)
  fourmulas_by_source <- translist(fourmulas_by_part)

  spflow_matrices <- named_list(c("CONST","D_","O_","I_","G_","Y_"))
  spflow_indicators <- subset_keycols(spflow_data[["pair"]], FALSE)

  spflow_matrices[["CONST"]] <- derive_spflow_constants(
    use_global_const = fourmulas_by_part[["constants"]][["global"]],
    use_intra_const = isTRUE(fourmulas_by_part[["constants"]][["intra"]]),
    use_instruments = spflow_control[["estimation_method"]] == "s2sls",
    spflow_indicators = spflow_indicators,
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]])


  ### transform and lag node data
  na_msg <- "NA's generated by formula part %s( . )!"
  assert_nodeobs <- function(fp, obs_X) assert(na_rm || all(obs_X), na_msg, fp)

  spflow_matrices[["D_"]] <- transform_node_data(
    threepart_formula = fourmulas_by_source[["D_"]],
    node_df = subset_keycols(spflow_data[["dest"]]),
    W = spflow_neighborhood[["DW"]],
    na_border2zero = spflow_control[["na_border2zero"]],
    prefix = "DEST_")
  obs_D <- spflow_matrices[["D_"]] %|!|% complete.cases
  assert_nodeobs("D_", obs_D)

  spflow_matrices[["O_"]] <- transform_node_data(
    threepart_formula = fourmulas_by_source[["O_"]],
    node_df = subset_keycols(spflow_data[["orig"]]),
    W = spflow_neighborhood[["OW"]],
    na_border2zero = spflow_control[["na_border2zero"]],
    prefix = "ORIG_")
  obs_O <- spflow_matrices[["O_"]] %|!|% complete.cases
  assert_nodeobs("O_", obs_O)

  spflow_matrices[["I_"]] <- transform_node_data(
    threepart_formula = fourmulas_by_source[["I_"]],
    node_df = subset_keycols(spflow_data[["orig"]]),
    W = spflow_neighborhood[["OW"]],
    na_border2zero = spflow_control[["na_border2zero"]],
    prefix = "INTRA_")
  obs_I <- spflow_matrices[["I_"]] %|!|% complete.cases
  assert_nodeobs("I_", obs_I)


  ### transform and lag od-pair data
  mform_na_cases <- function(mat_array) {
    mlist_complete_cases <- function(mat_list) Reduce("&", lapply(mat_list, is.na))
    na_cases <- Reduce("&",lapply(mat_array, mlist_complete_cases))

    if (!any(na_cases))
      return(NULL)

    return(na_cases)
  }
  assert_pairobs <- function(fp, na_X) assert(na_rm || is.null(na_X), na_msg, fp)

  spflow_matrices[["G_"]] <- transform_pair_data(
    threepart_formula = fourmulas_by_source[["G_"]],
    pair_df = subset_keycols(spflow_data[["pair"]]),
    spflow_indicators = spflow_indicators,
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]],
    na_border2zero = spflow_control[["na_border2zero"]],
    reduce_pair_instruments = isTRUE(spflow_control[["twosls_reduce_pair_instruments"]]))
  na_G <- spflow_matrices[["G_"]] %|!|% mform_na_cases
  assert_pairobs("G_", na_G)

  spflow_matrices[["Y_"]] <- transform_flow_data(
    threepart_formula = fourmulas_by_source[["Y_"]],
    flow_df = subset_keycols(spflow_data[["pair"]]),
    spflow_indicators = spflow_indicators,
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]],
    model = spflow_control[["model"]],
    na_border2zero = spflow_control[["na_border2zero"]])
  na_Y <- spflow_matrices[["Y_"]] %|!|% mform_na_cases
  assert_pairobs("Y_", na_Y)

  # identify which information sets are available for each od pair
  # ... predictions require signal
  update_conditions <- function(pre,add) if (is.null(pre)) add else pre & add
  HAS_SIG <- NULL
  do_indexes <- cbind(as.integer(spflow_indicators[[1]]), spflow_indicators[[2]])
  if (!all(obs_D))
    HAS_SIG <- update_conditions(HAS_SIG, obs_D[do_indexes[1]])

  if (!all(obs_O))
    HAS_SIG <- update_conditions(HAS_SIG, obs_O[do_indexes[2]])

  if (!all(obs_I))
    HAS_SIG <- update_conditions(HAS_SIG, (obs_I[do_indexes[2]] | spflow_indicators[[2]] != spflow_indicators[[1]]))

  if (!is.null(na_G))
    HAS_SIG <- update_conditions(HAS_SIG, !(na_G[do_indexes]))


  # ... model fitting requires signal, y, and non-zero weights
  HAS_Y <- HAS_SIG
  if (!is.null(na_Y) )
    HAS_Y <- update_conditions(HAS_Y, !(na_Y[do_indexes]))


  WEIGHT <- spflow_control[["weight_var"]]
  if (!is.null(WEIGHT) ) {
    WEIGHT <- spflow_data[[WEIGHT]]
    WEIGHT[WEIGHT <= 0] <- NA
    HAS_Y <- update_conditions(HAS_Y, is.finite(WEIGHT))
    WEIGHT[!HAS_Y] <- 0
  }

  extra_indicators <- cbind(HAS_SIG, HAS_Y, WEIGHT, ACTUAL = spflow_matrices[["Y_"]][[1]][do_indexes])
  spflow_indicators <- cbind(spflow_indicators, extra_indicators)
  return(c(spflow_matrices, list(spflow_indicators = spflow_indicators)))

  spflow_matrices <- transform_spflow_data(
    formula_parts = fourmulas_by_source,
    spflow_data = spflow_data,
    na_rm = na_rm,
    weights_var = spflow_control[["weight_variable"]],
    is_within = spflow_control[["is_within"]])


  variable_usage <- define_lags_and_instruments(
    fourmulas_by_source,
    lapply(spflow_data, "subset_keycols" , drop_keys = TRUE))
  spflow_matrices <- lag_spflow_matrices(
    variable_usage = variable_usage,
    spflow_matrices = spflow_matrices,
    spflow_neighborhood = spflow_neighborhood,
    spflow_indicators = spflow_matrices[["spflow_indicators"]],
    model = spflow_control[["model"]],
    decorrelate_instruments = isTRUE(spflow_control[["twosls_decorrelate_instruments"]]),
    reduce_pair_instruments = isTRUE(spflow_control[["twosls_reduce_pair_instruments"]]))


  constants <- list("CONST" = derive_spflow_constants(
    use_global_const = fourmulas_by_source[["constants"]][["global"]],
    use_intra_const = isTRUE(fourmulas_by_source[["constants"]][["intra"]]),
    use_instruments = spflow_control[["estimation_method"]] == "s2sls",
    spflow_indicators = spflow_matrices[["spflow_indicators"]],
    OW = spflow_neighborhood[["OW"]],
    DW = spflow_neighborhood[["DW"]]))
  return(c(constants, spflow_matrices))
}

#' @keywords internal
pull_spflow_data <- function(
  sp_multi_net,
  pair_id) {

  source_ids <- as.list(id(sp_multi_net@network_pairs[[pair_id]]))
  flow_data <- lapply(source_ids, function(.id){
    source_data <- dat(sp_multi_net, .id)
    row.names(source_data) <- NULL
    source_data
    })
  return(flow_data)
}

#' @keywords internal
get_keycols <- function(df) {
  c(attr_key_do(df),
    attr_key_nodes(df),
    attr_coord_col(df))
}

#' @keywords internal
subset_keycols <- function(df, drop_keys = TRUE) {
    keep_cols <- get_keycols(df)
  if (drop_keys)
    keep_cols <- setdiff(names(df), keep_cols)
  return(df[, keep_cols, drop = FALSE])
}


#' @keywords internal
define_lags_and_instruments <- function(formula_parts, data_sources) {

  formulas2sources  <- c(
    "D_" = "dest",
    "O_" = "orig",
    "I_" = "orig",
    "G_" = "pair",
    "Y_" = "pair")


  interpret_formulas <- function(.key_form) {
    .key_source <- formulas2sources[.key_form]
    derive_variables_use(variable_usage[[.key_form]], data_sources[[.key_source]])
  }

  variable_usage <- translist(formula_parts)[names(formulas2sources)]
  variable_usage <- compact(variable_usage)
  variable_usage <- lapply(lookup(names(variable_usage)), interpret_formulas)
  return(variable_usage)
}


#' @importFrom Matrix Diagonal
#' @keywords internal
derive_spflow_constants <- function(
    use_global_const,
    use_intra_const,
    use_instruments,
    spflow_indicators = NULL,
    OW = NULL,
    DW = NULL) {


  c_terms <- list("(Intercept)" =  `attr_inst_status<-`(1, !use_global_const))
  if (!use_intra_const)
    return(c_terms)

  n <- nlevels(spflow_indicators[[1]])
  c_terms <- c(c_terms, "(Intra)" = `attr_inst_status<-`(Diagonal(n), FALSE))
  if (!use_instruments)
    return(c_terms)

  # for computation of instruments the indicator is based on observed Y
  Y_indicator <- spflow_indicators2mat(spflow_indicators, do_filter = "HAS_Y")
  intra_lags <- double_lag_matrix(
    M = Diagonal(n),
    OW = OW,
    DW = DW,
    name = "(Intra)",
    key = "I",
    M_indicator = Y_indicator,
    symmetric_lags = is.null(Y_indicator),
    lag_order = 2,
    return_all_lags = TRUE,
    lags_are_instruments = TRUE)
  return(c(c_terms, intra_lags[-1]))
}


#' @keywords internal
derive_variables_use <- function(
    formula_part,
    data_source) {

  var_use <- lapply(formula_part, "predict_tranfomed_vars", data_source)
  var_use_types <- named_list(c("norm","sdm","inst"))
  var_use_types[names(var_use)] <- var_use

  all_vars <- unique(unlist(var_use, use.names = FALSE))
  get_v_use <- function(.v) data.frame(lapply(var_use_types, function(.u) any(.u == .v)))
  var_use_df <- do.call("rbind", lapply(lookup(all_vars), get_v_use))
  var_use_df[["num_lags"]] <- var_use_df[["sdm"]] + 2 * var_use_df[["inst"]]

  inst_attr <- Map(
    function(norm, sdm, num_lags){

      inst_statu <- rep(TRUE, num_lags + 1)
      inst_statu[1] <- !norm
      if(num_lags >= 1)
        inst_statu[2] <- !sdm
      inst_statu
    },
    var_use_df$norm, var_use_df$sdm, var_use_df$num_lags)

  var_use_df[["inst_attr"]] <- I(inst_attr)
  var_use_df
}
