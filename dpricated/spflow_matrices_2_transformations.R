#' @title Internal functions to generate model matrices
#' @details
#'   Sources describe the data.frames holding the original information on
#'   the nodes and the node pairs. There are three possible source data.frame
#'   which are referred to as "pair", "orig", or "dest".
#'   All formulas (normal, sdm, and instrument) are combined to generate an
#'   overall model matrix which is only expanded once for each source.
#' @return A list of matrices
#' @keywords internal
transform_spflow_data <- function(
    formula_parts,
    spflow_data,
    na_rm,
    weights_var,
    is_within) {

  formulas2sources  <- c(
    "D_" = ifelse(is_within, "orig", "dest"),
    "O_" = "orig",
    "I_" = "orig",
    "G_" = "pair",
    "Y_" = "pair")

  formulas4trans <- translist(formula_parts)[names(formulas2sources)]
  formulas4trans <- lapply(
    formulas4trans[intersect(names(formulas4trans), names(formulas2sources))],
    "combine_rhs_formulas")

  for (i in seq_along(spflow_data))
    row.names(spflow_data) <- NULL

  # transform nodes variables
  transform_in_source <- function(.key, .na_rm = na_rm, filter = NULL) {

    this_formula <- formulas4trans[[.key]]
    if (is.null(this_formula))
      return(NULL)

    this_source <- formulas2sources[.key]
    this_source <- subset_keycols(spflow_data[[this_source]], drop_keys = TRUE)
    if (!is.null(filter))
      this_source <- this_source[filter,,drop = FALSE]
    this_mat <- flow_conform_model_matrix(this_formula, this_source)

    lost_cases <- nrow(this_mat) < nrow(this_source)
    assert(.na_rm || !lost_cases, "NA's generated by formula part %s(...)!", .key)
    return(this_mat)
  }
  node_formulas <- c("D_","O_", "I_")
  node_matrices <- lapply(lookup(node_formulas), transform_in_source)

  # ...if there are lost observations in the node matrices
  lost_nodes <- lapply(lookup(node_formulas), function(.f) get_lostobs(
    pre = spflow_data[[formulas2sources[.f]]],
    trans = node_matrices[[.f]]))
  node_matrices <- Map(impute_lost_cases, node_matrices, lost_nodes, imp = NA)
  lost_nodes <- compact(lost_nodes) %||% NULL

  # ...we will not be able to compute the signal for the corresponding pair
  wt <- weights_var %|!|% as.numeric(spflow_data[["pair"]][[weights_var]])
  spflow_indicators <- get_do_keys(spflow_data[["pair"]])
  HAS_SIG <- NULL
  if (!is.null(lost_nodes)) {
    pair_indexes <- c("D_" = 1,"O_" = 2, "I_" = 2)[names(lost_nodes)]
    pair_indexes <- spflow_indicators[,as.numeric(pair_indexes), drop = FALSE]
    HAS_SIG <- Map(function(.l, .i) (!.l)[as.numeric(.i)], .l = lost_nodes, .i = pair_indexes)
    HAS_SIG <- Reduce("&", HAS_SIG)
  }

  # transform pair variables
  G_matrices <- transform_in_source("G_", na_rm,filter = HAS_SIG)
  G_losses <- get_lostobs(spflow_indicators, G_matrices)
  if (!is.null(G_losses)) {
    HAS_SIG  <- if (is.null(HAS_SIG)) !G_losses else !G_losses & HAS_SIG
  }

  # transform y variables
  # when there is no signal we cannot use y....
  HAS_Y <- NULL
  if (!is.null(wt)) {
    wt_valid <- (is.finite(wt) & wt > 0)
    assert(na_rm || all(wt_valid), "The weights contain NA/NaN/Inf/negative values!")
    HAS_Y <- if (is.null(HAS_Y)) wt_valid else wt_valid & HAS_Y
  }

  Y_matrices <- transform_in_source("Y_", na_rm, filter = HAS_Y)
  Y_losses <- get_lostobs(spflow_indicators, Y_matrices)
  if (!is.null(Y_losses)) {
    HAS_Y <- !Y_losses
    if (!is.null(wt))
      wt[Y_losses] <- 0
  }

  # in the indicators signal whether for model fitting and prediction
  # also store the dependent variables to compute residuals later
  Y_cases <- HAS_Y %||% TRUE
  G_cases <- HAS_SIG %||% TRUE
  extra_indicators <- data.frame(ACTUAL = NA)
  if (!is.null(wt))
    extra_indicators <- cbind(extra_indicators, WEIGHT = wt)
  if (!is.null(HAS_SIG))
    extra_indicators <- cbind(extra_indicators, HAS_SIG)
  if (!is.null(HAS_Y))
    extra_indicators <- cbind(extra_indicators, HAS_Y)
  spflow_indicators <- cbind(spflow_indicators, extra_indicators)
  spflow_indicators[,"ACTUAL"][Y_cases] <- Y_matrices

  # matrix format pair variables
  Y_matrices <- Y_matrices %|!|% spflow_indicators2matlist(cbind(spflow_indicators[Y_cases, 1:2, drop = FALSE], Y_matrices))
  G_matrices <- G_matrices %|!|% spflow_indicators2matlist(cbind(spflow_indicators[G_cases, 1:2, drop = FALSE], G_matrices))
  pair_matrices <- list(
    "G_" = G_matrices,
    "Y_" = Y_matrices,
    "spflow_indicators" = spflow_indicators)

  return(c(node_matrices, pair_matrices))
}

#' @keywords internal
combine_formulas_by_source <- function(sources, formulas) {

  is_between_flow <- ("dest" %in% sources)
  sources_to_formula_part <- list(
    "pair" = c("Y_","G_"),
    "dest" = c("D_") %T% is_between_flow,
    "orig" = (c("O_") %T% is_between_flow) %||% c("D_","O_","I_"))

  formula_by_source <-
    lapply(compact(sources_to_formula_part), function(.part) {
      fpt <- compact(formulas[.part])
      fpt %|!|% combine_rhs_formulas(fpt) })

  return(compact(formula_by_source))
}









